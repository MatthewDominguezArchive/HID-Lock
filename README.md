## What is a BadUSB / USB Rubber Ducky attack?
A BadUSB / USB Rubber Ducky is a physical device that is programmed to be identified as a HID on a victims machine. HID stands for human interface device. Common examples are keyboards, mice, webcams, microphones, headphones, etc. Anything to connect a human to a machine. A HID attack device can simply be plugged in, quickly press keystrokes that will either open a reverse shell, download malware, etc. Unfortunately, Windows and other operating systems have very little protection from someone plugging in one of these devices and causing havoc. As a matter of fact there is no protection against these devices by Windows Defender and most Anti-Viruses as a whole. The reason is because these attacks are rare, and plugging in new devices is extremely common. Also, how do you distinguish a HID emulator from a real HID? It's very difficult. Some may try a firmware approach. Firmware is the description advertised by the HID to inform the operating system on the type of HID, baudrate, and occasionally manufacturer brand and serial numbers. You can compare these device descriptors to a whitelist, or heuristically check if the descriptors "seem" legit. But this is not fool proof, and actually totally worthless if the HID emulator also emulates their firmware to exactly match a valid HID.

## What can we do?
My idea for this project was to create a locking mechanism. Once the HIDs are set up for the computer, a lock will block any future HID connections while perserving regular functionality for the HID's that existed before the lock. This means that if you are working at a computer in a coffee shop, nobody can just walk up and plug in an attack device and cause harm. It will instantly block the device. If you choose to connect a new device, a microphone for example. You can restart your computer and relock your HIDs after having plugged in the new device.

## Brainstorming the idea
Lets break this down into two distinct steps, detection and blockage. First we must detect that a new device has been connected. Then we must find a way to block it. We can set up an infinite loop in usermode that constantly uses something like SetupDiEnumDeviceInterfaces to find a list to all HIDs, if a new one appears then we know to block it. We can intercept the keystrokes via SetWindowsHookEx and overwrite them with some null value. This sounds good on paper, but here's the issue. High frequency looping would cause bad performance drops. We could add a delay for each iteration, allowing for the cpu to execute less commands over a given period. But if we are adding too large of a delay it can open a window for a HID attack to occur during the downtime. And if we add a shorter delay, we are once again taking up more resources. Considering how rare these attacks are, it's not worth having this performance issues. Especially in an enviornment where resources are limited.

Next, I thought of leaving a low-level hook somewhere in the operating system that would jump to my code when a new device is plugged in. This is an unorthodox thought process, and would cause headbutting with anti-viruses, or more importantly patchguard. You can't simply hook anything, especially not patchguard protected kernel instructions. It's also unsafe because of compatibility issues. Many things change from one windows update to another and could potentially fail on certain computers. Before bashing this idea away, one good thing about this idea is that our locking mechanism is using almost no resources during the uneventful periods (like when no HIDs are being plugged in).

Finally I came up with the answer, a filter driver. I first read about this in the Windows Internals book. A filter driver is an abstraction layer between the software and drivers. It allows for an IRP to be processed before reaching it's destination. The way your operating system interacts with your HIDs is by first sending it some requests to read firmware. And then interacting with it accordingly. In the case of a keyboard (most common HID emulation for attack), the operating system sends an irp to the keyboard's HID driver and asks it to check the state of the keys on the keyboard. If we apply a filter driver to this HID driver, we can completely zero out the irp and on top of that make it so that the keyboard driver never even recieves the irp. This method is better than the hooking method, because not only are we staying insanely resource minded, but also working safely. This is the best course of action.

![Filter Driver Diagram](https://i.imgur.com/4V5vmee.png)


## Addressing the Entry Point situation
Windows will not let you install a driver onto your computer that doesn't have a valid certificate from windows. [KdMapper](https://github.com/TheCruZ/kdmapper) is a github project that exploits a vulnerable driver into mapping an unsigned driver into kernel space. This allows for me, someone who isn't going to pay a rediculous price for a windows certificate to load a kernel driver. You can also turn on test signing for windows that allows for you to normally load an unsigned driver with NtLoadDriver, but I don't like having a watermark on my screen :) KdMapper will call your driver's entry point, but not pass through any arguments (like driver object which we need). This is because KdMapper actually doesn't create a driver object when it maps your driver. Which is good in stealthy scenarios, which doesn't apply here. Therefore I let KdMapper call my "fake" entry point where I create my own driver object and call the "real" entry point that now has a driver object. If you don't want to use KdMapper please change your configuration settings on the top of visual studio from KdMapper to NtLoadDriver. This will make it so that none of the KdMapper hula hoops compiled.

## Final Remarks
I left so many comments in there for any curious people who want to go thru line by line, it's a fairly simple project but confusing if you are unfamiliar with kernel land.
